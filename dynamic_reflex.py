# app/dynamic_reflex.py                         3CY-SmartBeesSwarm
# DYNAMIC REFLEX - Executable reflex from JSON definition
# Can be generated by LLM or downloaded from blockchain
# REASON: Reflexes must evolve, not be hardcoded in Python

import logging
import time
import signal
from typing import Any, Callable, Dict, Optional

class TimeoutException(Exception):
    """Exception raised when reflex evaluation exceeds timeout."""
    pass

def timeout_handler(signum, frame):
    """Signal handler for timeout."""
    raise TimeoutException("Reflex evaluation timeout")

class DynamicReflex:
    """
    Executable reflex created from JSON definition.
    
    ARCHITECTURE:
    â€¢ Compiled from JSON by ReflexDefinitionManager
    â€¢ Trigger: Callable (telemetry â†’ bool)
    â€¢ Action: Callable (telemetry â†’ action dict)
    â€¢ Learning: Integrates with OnlineLearner
    â€¢ Statistics: Tracks performance for evolution
    
    LIFECYCLE:
    1. Created by ReflexDefinitionManager.load_reflex_definition()
    2. Registered in TacticalReflexSystem
    3. Checked every frame (60 Hz)
    4. If triggered â†’ generates action
    5. After execution â†’ records outcome (reward)
    6. Statistics used for:
       - Performance monitoring
       - LLM re-analysis (if poor performance)
       - Blockchain sharing (if excellent performance)
    
    SOURCES:
    â€¢ BUILTIN: Shipped with firmware (e.g., ANTISNIPER)
    â€¢ LLM_GENERATED: Created by AI during charging
    â€¢ BLOCKCHAIN_SYNC: Downloaded from other drones
    â€¢ OPERATOR_CUSTOM: Manually defined by human
    """
    
    # FIX 1: Timeout protection constants
    TRIGGER_TIMEOUT_SEC = 0.005  # 5ms max for trigger evaluation
    ACTION_TIMEOUT_SEC = 0.010   # 10ms max for action generation
    
    def __init__(
        self,
        name: str,
        trigger_evaluator: Callable[[Dict[str, Any]], bool],
        action_generator: Callable[[Dict[str, Any]], Dict[str, float]],
        priority: int,
        cooldown: float = 5.0,
        learner=None,
        metadata: Optional[Dict[str, Any]] = None
    ):
        """
        Initialize dynamic reflex.
        
        Args:
            name: Unique reflex identifier (e.g., "ALTITUDE_ESCAPE")
            trigger_evaluator: Compiled trigger function (telemetry â†’ bool)
            action_generator: Compiled action function (telemetry â†’ action dict)
            priority: Execution priority (0-200, higher = more important)
            cooldown: Minimum seconds between triggers
            learner: OnlineLearner instance for AI-optimized actions
            metadata: Additional info (description, source, risk_level)
        """
        try:
            self.name = name
            self.trigger = trigger_evaluator
            self.generate_action = action_generator
            self.priority = priority
            self.cooldown = cooldown
            self.learner = learner
            self.metadata = metadata or {}
            
            # State
            self.enabled = True
            self.last_triggered = 0.0
            
            # Statistics for evolution
            self.trigger_count = 0
            self.success_count = 0
            self.failure_count = 0
            self.avg_reward = 0.0
            
            # Performance tracking
            self.last_10_rewards = []  # Rolling window for recent performance
            self.total_reward = 0.0
            
            # Timing statistics
            self.avg_execution_time = 0.0
            self.max_execution_time = 0.0
            
            # FIX 1: Timeout statistics
            self.timeout_count = 0
            self.last_timeout = 0.0
            
            logging.info(
                f"âœ… DynamicReflex '{name}' initialized "
                f"(Priority: {priority}, Source: {self.metadata.get('source', 'UNKNOWN')})"
            )
            
        except Exception:
            logging.exception(f"CRASH in DynamicReflex.__init__ ({name})")
            raise
    
    def check(
        self, 
        telemetry: Dict[str, Any], 
        time_now: float
    ) -> Optional[Dict[str, Any]]:
        """
        Check if reflex should trigger and generate action.
        
        FIX 1: Added timeout protection for trigger and action evaluation.
        
        PROCESS:
        1. Check if enabled
        2. Check cooldown
        3. Evaluate trigger conditions (WITH TIMEOUT)
        4. If triggered â†’ generate action (WITH TIMEOUT)
        5. Add metadata to action dict
        
        Args:
            telemetry: Full telemetry dict (36+ features)
            time_now: Current timestamp
            
        Returns:
            Action dict if triggered, else None
            
        Action dict format:
        {
            'throttle': float (0.0-1.0),
            'pitch': float (-1.0-1.0),
            'roll': float (-1.0-1.0),
            'yaw': float (-1.0-1.0),
            'tactical_action': str (e.g., "EVASIVE_GUNSHOT"),
            'reason': str (e.g., "ALTITUDE_ESCAPE_TRIGGERED"),
            'reflex_name': str (for tracking),
            'priority': int (for conflict resolution)
        }
        """
        try:
            # Check if enabled
            if not self.enabled:
                return None
            
            # Check cooldown
            if time_now - self.last_triggered < self.cooldown:
                return None
            
            # FIX 1: Evaluate trigger with timeout protection
            start_time = time.perf_counter()
            try:
                # Set alarm for timeout
                signal.signal(signal.SIGALRM, timeout_handler)
                signal.alarm(1)  # 1 second absolute max
                
                triggered = self.trigger(telemetry)
                
                # Cancel alarm
                signal.alarm(0)
                
            except TimeoutException:
                self.timeout_count += 1
                self.last_timeout = time_now
                logging.error(
                    f"â±ï¸ [{self.name}] TRIGGER TIMEOUT! "
                    f"(Count: {self.timeout_count}, Disabling reflex)"
                )
                # Auto-disable after 3 timeouts
                if self.timeout_count >= 3:
                    self.disable(reason="REPEATED_TIMEOUTS")
                return None
            finally:
                signal.alarm(0)
            
            trigger_time = time.perf_counter() - start_time
            
            # Warn if trigger is slow (>5ms)
            if trigger_time > self.TRIGGER_TIMEOUT_SEC:
                logging.warning(
                    f"âš ï¸ [{self.name}] Slow trigger: {trigger_time*1000:.1f}ms "
                    f"(Threshold: {self.TRIGGER_TIMEOUT_SEC*1000:.1f}ms)"
                )
            
            if not triggered:
                return None
            
            # Trigger confirmed!
            self.last_triggered = time_now
            self.trigger_count += 1
            
            # FIX 1: Generate action with timeout protection
            action_start = time.perf_counter()
            try:
                # Set alarm for timeout
                signal.signal(signal.SIGALRM, timeout_handler)
                signal.alarm(1)  # 1 second absolute max
                
                action = self.generate_action(telemetry)
                
                # Cancel alarm
                signal.alarm(0)
                
            except TimeoutException:
                self.timeout_count += 1
                self.last_timeout = time_now
                logging.error(
                    f"â±ï¸ [{self.name}] ACTION TIMEOUT! "
                    f"(Count: {self.timeout_count}, Using safe default)"
                )
                # Use safe default action
                action = {
                    'throttle': 0.5,
                    'pitch': 0.0,
                    'roll': 0.0,
                    'yaw': 0.0
                }
            finally:
                signal.alarm(0)
            
            action_time = time.perf_counter() - action_start
            
            # Warn if action generation is slow (>10ms)
            if action_time > self.ACTION_TIMEOUT_SEC:
                logging.warning(
                    f"âš ï¸ [{self.name}] Slow action: {action_time*1000:.1f}ms "
                    f"(Threshold: {self.ACTION_TIMEOUT_SEC*1000:.1f}ms)"
                )
            
            # Update timing statistics
            total_time = trigger_time + action_time
            self.avg_execution_time = (
                0.9 * self.avg_execution_time + 0.1 * total_time
            )
            self.max_execution_time = max(self.max_execution_time, total_time)
            
            # Warn if total execution is slow (>15ms = 90% of 60Hz frame)
            if total_time > 0.015:
                logging.warning(
                    f"âš ï¸ [{self.name}] Slow reflex execution: {total_time*1000:.1f}ms "
                    f"(Trigger: {trigger_time*1000:.1f}ms, Action: {action_time*1000:.1f}ms)"
                )
            
            # Add metadata to action
            action['reflex_name'] = self.name
            action['priority'] = self.priority
            action['reason'] = f'{self.name}_TRIGGERED'
            
            # Add tactical action if not specified
            if 'tactical_action' not in action:
                action['tactical_action'] = self._infer_tactical_action(action)
            
            # Log trigger
            logging.warning(
                f"âš¡ REFLEX TRIGGERED: {self.name} "
                f"(Priority: {self.priority}, "
                f"Source: {self.metadata.get('source', 'UNKNOWN')})"
            )
            
            # Debug info
            logging.debug(
                f"   Action: throttle={action.get('throttle', 0.5):.2f}, "
                f"pitch={action.get('pitch', 0.0):.2f}, "
                f"roll={action.get('roll', 0.0):.2f}, "
                f"yaw={action.get('yaw', 0.0):.2f}"
            )
            
            return action
            
        except Exception:
            logging.exception(f"CRASH in {self.name}.check")
            return None
    
    def _infer_tactical_action(self, action: Dict[str, float]) -> str:
        """
        Infer tactical action type from control parameters.
        
        HEURISTICS:
        â€¢ High throttle (>0.8) â†’ CLIMB
        â€¢ Low throttle (<0.2) â†’ DIVE
        â€¢ High roll (>0.5) â†’ LATERAL_DODGE
        â€¢ High pitch (>0.5) â†’ FORWARD_ESCAPE
        â€¢ Mix â†’ EVASIVE_MANEUVER
        
        Used when action_generator doesn't specify tactical_action.
        """
        try:
            throttle = action.get('throttle', 0.5)
            pitch = abs(action.get('pitch', 0.0))
            roll = abs(action.get('roll', 0.0))
            yaw = abs(action.get('yaw', 0.0))
            
            if throttle > 0.8:
                return "CLIMB_ESCAPE"
            elif throttle < 0.2:
                return "DIVE_EVASION"
            elif roll > 0.5:
                return "LATERAL_DODGE"
            elif pitch > 0.5:
                return "FORWARD_ESCAPE"
            elif yaw > 0.5:
                return "ROTATION_MANEUVER"
            else:
                return "EVASIVE_MANEUVER"
                
        except Exception:
            logging.exception(f"CRASH in {self.name}._infer_tactical_action")
            return "UNKNOWN_MANEUVER"
    
    def record_outcome(
        self, 
        success: bool, 
        reward: float,
        execution_time: Optional[float] = None
    ):
        """
        Record reflex outcome for statistics and learning.
        
        FIX 2: Added auto-disable for harmful reflexes.
        
        Called by TacticalReflexSystem after action execution.
        
        STATISTICS TRACKED:
        â€¢ Success/failure counts
        â€¢ Average reward (exponential moving average)
        â€¢ Recent performance (last 10 actions)
        â€¢ Total accumulated reward
        
        USED FOR:
        â€¢ Performance monitoring
        â€¢ LLM re-analysis trigger (if poor performance)
        â€¢ Blockchain sharing decision (if excellent performance)
        â€¢ Automatic disabling (if consistently harmful)
        
        Args:
            success: True if action achieved goal (positive reward)
            reward: Numerical reward from RewardCalculator
            execution_time: Optional execution duration in seconds
        """
        try:
            # Update counts
            if success:
                self.success_count += 1
            else:
                self.failure_count += 1
            
            # Update average reward (exponential moving average)
            alpha = 0.1  # Learning rate for statistics
            self.avg_reward = (1 - alpha) * self.avg_reward + alpha * reward
            
            # Update total reward
            self.total_reward += reward
            
            # Update recent performance window
            self.last_10_rewards.append(reward)
            if len(self.last_10_rewards) > 10:
                self.last_10_rewards.pop(0)
            
            # Calculate recent performance
            recent_avg = (
                sum(self.last_10_rewards) / len(self.last_10_rewards)
                if self.last_10_rewards else 0.0
            )
            
            # Log outcome
            logging.debug(
                f"[{self.name}] Outcome recorded: "
                f"Success={success}, Reward={reward:.2f}, "
                f"Avg={self.avg_reward:.2f}, Recent={recent_avg:.2f}"
            )
            
            # Check for poor performance
            if self.trigger_count >= 10:
                success_rate = self.success_count / self.trigger_count
                
                if success_rate < 0.3:
                    logging.warning(
                        f"âš ï¸ [{self.name}] LOW SUCCESS RATE: {success_rate:.1%} "
                        f"({self.success_count}/{self.trigger_count})"
                    )
                
                # FIX 2: Check if consistently harmful and AUTO-DISABLE
                if recent_avg < -2.0 and len(self.last_10_rewards) >= 10:
                    logging.error(
                        f"ðŸš¨ [{self.name}] HARMFUL REFLEX DETECTED! "
                        f"Recent avg reward: {recent_avg:.2f}. "
                        f"AUTO-DISABLING!"
                    )
                    self.disable(reason="HARMFUL_PERFORMANCE")
                    
                    # FIX 2: Log critical event for operator alert
                    logging.critical(
                        f"ðŸš¨ CRITICAL: Reflex '{self.name}' auto-disabled due to "
                        f"harmful performance (avg reward {recent_avg:.2f} over 10 executions)"
                    )
            
            # Check for excellent performance (blockchain sharing candidate)
            if self.trigger_count >= 20:
                success_rate = self.success_count / self.trigger_count
                
                if success_rate > 0.85 and self.avg_reward > 1.5:
                    logging.info(
                        f"â­ [{self.name}] EXCELLENT PERFORMANCE: "
                        f"{success_rate:.1%} success, avg reward {self.avg_reward:.2f}. "
                        f"Candidate for blockchain sharing!"
                    )
            
        except Exception:
            logging.exception(f"CRASH in {self.name}.record_outcome")
    
    def get_statistics(self) -> Dict[str, Any]:
        """
        Get detailed statistics for this reflex.
        
        Returns:
            dict: Performance metrics for monitoring and evolution
        """
        try:
            success_rate = (
                self.success_count / self.trigger_count 
                if self.trigger_count > 0 else 0.0
            )
            
            recent_avg = (
                sum(self.last_10_rewards) / len(self.last_10_rewards)
                if self.last_10_rewards else 0.0
            )
            
            return {
                'name': self.name,
                'enabled': self.enabled,
                'priority': self.priority,
                'source': self.metadata.get('source', 'UNKNOWN'),
                'description': self.metadata.get('description', ''),
                'risk_level': self.metadata.get('risk_level', 'MEDIUM'),
                
                # Execution statistics
                'trigger_count': self.trigger_count,
                'success_count': self.success_count,
                'failure_count': self.failure_count,
                'success_rate': success_rate,
                
                # Reward statistics
                'avg_reward': self.avg_reward,
                'total_reward': self.total_reward,
                'recent_avg_reward': recent_avg,
                
                # Performance statistics
                'avg_execution_time_ms': self.avg_execution_time * 1000,
                'max_execution_time_ms': self.max_execution_time * 1000,
                
                # FIX 1: Timeout statistics
                'timeout_count': self.timeout_count,
                'last_timeout': self.last_timeout,
                
                # Status
                'status': self._get_status()
            }
            
        except Exception:
            logging.exception(f"CRASH in {self.name}.get_statistics")
            return {'name': self.name, 'error': 'Failed to get statistics'}
    
    def _get_status(self) -> str:
        """
        Get current reflex status based on performance.
        
        STATUS LEVELS:
        â€¢ EXCELLENT: >85% success, avg reward >1.5
        â€¢ GOOD: >70% success, avg reward >0.5
        â€¢ MODERATE: >50% success, avg reward >0
        â€¢ POOR: <50% success or negative reward
        â€¢ HARMFUL: Recent avg reward < -2.0 (auto-disabled)
        â€¢ UNTESTED: <10 triggers
        """
        try:
            if self.trigger_count < 10:
                return "UNTESTED"
            
            success_rate = self.success_count / self.trigger_count
            recent_avg = (
                sum(self.last_10_rewards) / len(self.last_10_rewards)
                if self.last_10_rewards else 0.0
            )
            
            # FIX 2: Check for harmful (should be disabled)
            if recent_avg < -2.0 and len(self.last_10_rewards) >= 10:
                return "HARMFUL"
            
            # Check performance levels
            if success_rate > 0.85 and self.avg_reward > 1.5:
                return "EXCELLENT"
            elif success_rate > 0.70 and self.avg_reward > 0.5:
                return "GOOD"
            elif success_rate > 0.50 and self.avg_reward > 0:
                return "MODERATE"
            else:
                return "POOR"
                
        except Exception:
            logging.exception(f"CRASH in {self.name}._get_status")
            return "UNKNOWN"
    
    def reset_statistics(self):
        """
        Reset statistics (useful after major changes or LLM re-analysis).
        """
        try:
            self.trigger_count = 0
            self.success_count = 0
            self.failure_count = 0
            self.avg_reward = 0.0
            self.last_10_rewards = []
            self.total_reward = 0.0
            self.avg_execution_time = 0.0
            self.max_execution_time = 0.0
            
            # FIX 1: Reset timeout statistics
            self.timeout_count = 0
            self.last_timeout = 0.0
            
            logging.info(f"[{self.name}] Statistics reset")
            
        except Exception:
            logging.exception(f"CRASH in {self.name}.reset_statistics")
    
    def disable(self, reason: str = "Manual"):
        """
        Disable reflex (stops triggering).
        
        Used for:
        â€¢ Poor performance (automatic)
        â€¢ Operator override (manual)
        â€¢ Conflicting reflexes (automatic)
        â€¢ Repeated timeouts (automatic)
        """
        try:
            self.enabled = False
            logging.warning(f"ðŸš« [{self.name}] DISABLED (Reason: {reason})")
        except Exception:
            logging.exception(f"CRASH in {self.name}.disable")
    
    def enable(self):
        """
        Re-enable reflex.
        """
        try:
            self.enabled = True
            logging.info(f"âœ… [{self.name}] ENABLED")
        except Exception:
            logging.exception(f"CRASH in {self.name}.enable")
    
    def __repr__(self) -> str:
        """String representation for debugging."""
        return (
            f"DynamicReflex(name='{self.name}', priority={self.priority}, "
            f"enabled={self.enabled}, triggers={self.trigger_count}, "
            f"success_rate={self.success_count/self.trigger_count if self.trigger_count > 0 else 0:.1%})"
        )
    
    def __str__(self) -> str:
        """User-friendly string representation."""
        return f"{self.name} (Priority: {self.priority}, Status: {self._get_status()})"
